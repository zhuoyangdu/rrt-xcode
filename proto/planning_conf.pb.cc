// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: planning_conf.proto

#include "planning_conf.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_planning_5fconf_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_FakeState_planning_5fconf_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_planning_5fconf_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Goal_planning_5fconf_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_planning_5fconf_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_RRTConf_planning_5fconf_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_planning_5fconf_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_VrepConf_planning_5fconf_2eproto;
namespace planning {
class RRTConfDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<RRTConf> _instance;
} _RRTConf_default_instance_;
class VrepConfDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<VrepConf> _instance;
} _VrepConf_default_instance_;
class GoalDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Goal> _instance;
} _Goal_default_instance_;
class FakeStateDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<FakeState> _instance;
} _FakeState_default_instance_;
class PlanningConfDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<PlanningConf> _instance;
} _PlanningConf_default_instance_;
}  // namespace planning
static void InitDefaultsRRTConf_planning_5fconf_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::planning::_RRTConf_default_instance_;
    new (ptr) ::planning::RRTConf();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::planning::RRTConf::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_RRTConf_planning_5fconf_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsRRTConf_planning_5fconf_2eproto}, {}};

static void InitDefaultsVrepConf_planning_5fconf_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::planning::_VrepConf_default_instance_;
    new (ptr) ::planning::VrepConf();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::planning::VrepConf::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_VrepConf_planning_5fconf_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsVrepConf_planning_5fconf_2eproto}, {}};

static void InitDefaultsGoal_planning_5fconf_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::planning::_Goal_default_instance_;
    new (ptr) ::planning::Goal();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::planning::Goal::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Goal_planning_5fconf_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsGoal_planning_5fconf_2eproto}, {}};

static void InitDefaultsFakeState_planning_5fconf_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::planning::_FakeState_default_instance_;
    new (ptr) ::planning::FakeState();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::planning::FakeState::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_FakeState_planning_5fconf_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsFakeState_planning_5fconf_2eproto}, {}};

static void InitDefaultsPlanningConf_planning_5fconf_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::planning::_PlanningConf_default_instance_;
    new (ptr) ::planning::PlanningConf();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::planning::PlanningConf::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<4> scc_info_PlanningConf_planning_5fconf_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 4, InitDefaultsPlanningConf_planning_5fconf_2eproto}, {
      &scc_info_RRTConf_planning_5fconf_2eproto.base,
      &scc_info_VrepConf_planning_5fconf_2eproto.base,
      &scc_info_Goal_planning_5fconf_2eproto.base,
      &scc_info_FakeState_planning_5fconf_2eproto.base,}};

void InitDefaults_planning_5fconf_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_RRTConf_planning_5fconf_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_VrepConf_planning_5fconf_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Goal_planning_5fconf_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_FakeState_planning_5fconf_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_PlanningConf_planning_5fconf_2eproto.base);
}

::google::protobuf::Metadata file_level_metadata_planning_5fconf_2eproto[5];
constexpr ::google::protobuf::EnumDescriptor const** file_level_enum_descriptors_planning_5fconf_2eproto = nullptr;
constexpr ::google::protobuf::ServiceDescriptor const** file_level_service_descriptors_planning_5fconf_2eproto = nullptr;

const ::google::protobuf::uint32 TableStruct_planning_5fconf_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::planning::RRTConf, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::RRTConf, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::RRTConf, time_step_),
  PROTOBUF_FIELD_OFFSET(::planning::RRTConf, k_voronoi_),
  PROTOBUF_FIELD_OFFSET(::planning::RRTConf, k_goal_),
  PROTOBUF_FIELD_OFFSET(::planning::RRTConf, show_image_),
  PROTOBUF_FIELD_OFFSET(::planning::RRTConf, max_attemp_),
  PROTOBUF_FIELD_OFFSET(::planning::RRTConf, step_size_),
  PROTOBUF_FIELD_OFFSET(::planning::RRTConf, turn_on_prior_),
  PROTOBUF_FIELD_OFFSET(::planning::RRTConf, k_repulsive_),
  PROTOBUF_FIELD_OFFSET(::planning::RRTConf, post_iteration_),
  PROTOBUF_FIELD_OFFSET(::planning::RRTConf, record_),
  PROTOBUF_FIELD_OFFSET(::planning::RRTConf, record_path_),
  PROTOBUF_FIELD_OFFSET(::planning::RRTConf, uniform_sample_),
  PROTOBUF_FIELD_OFFSET(::planning::RRTConf, pivots_k_),
  1,
  2,
  3,
  7,
  4,
  5,
  8,
  6,
  11,
  9,
  0,
  10,
  12,
  PROTOBUF_FIELD_OFFSET(::planning::VrepConf, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::VrepConf, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::VrepConf, resolutionx_),
  PROTOBUF_FIELD_OFFSET(::planning::VrepConf, resolutiony_),
  PROTOBUF_FIELD_OFFSET(::planning::VrepConf, minx_),
  PROTOBUF_FIELD_OFFSET(::planning::VrepConf, maxx_),
  PROTOBUF_FIELD_OFFSET(::planning::VrepConf, miny_),
  PROTOBUF_FIELD_OFFSET(::planning::VrepConf, maxy_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::planning::Goal, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::Goal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::Goal, row_),
  PROTOBUF_FIELD_OFFSET(::planning::Goal, col_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::planning::FakeState, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::FakeState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::FakeState, x_),
  PROTOBUF_FIELD_OFFSET(::planning::FakeState, y_),
  PROTOBUF_FIELD_OFFSET(::planning::FakeState, theta_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::planning::PlanningConf, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::PlanningConf, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::PlanningConf, use_sim_time_),
  PROTOBUF_FIELD_OFFSET(::planning::PlanningConf, rrt_conf_),
  PROTOBUF_FIELD_OFFSET(::planning::PlanningConf, vrep_conf_),
  PROTOBUF_FIELD_OFFSET(::planning::PlanningConf, goal_),
  PROTOBUF_FIELD_OFFSET(::planning::PlanningConf, map_from_file_),
  PROTOBUF_FIELD_OFFSET(::planning::PlanningConf, map_path_),
  PROTOBUF_FIELD_OFFSET(::planning::PlanningConf, fake_state_),
  5,
  1,
  2,
  3,
  6,
  0,
  4,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 18, sizeof(::planning::RRTConf)},
  { 31, 42, sizeof(::planning::VrepConf)},
  { 48, 55, sizeof(::planning::Goal)},
  { 57, 65, sizeof(::planning::FakeState)},
  { 68, 80, sizeof(::planning::PlanningConf)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::planning::_RRTConf_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::planning::_VrepConf_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::planning::_Goal_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::planning::_FakeState_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::planning::_PlanningConf_default_instance_),
};

::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_planning_5fconf_2eproto = {
  {}, AddDescriptors_planning_5fconf_2eproto, "planning_conf.proto", schemas,
  file_default_instances, TableStruct_planning_5fconf_2eproto::offsets,
  file_level_metadata_planning_5fconf_2eproto, 5, file_level_enum_descriptors_planning_5fconf_2eproto, file_level_service_descriptors_planning_5fconf_2eproto,
};

::google::protobuf::internal::DescriptorTable descriptor_table_planning_5fconf_2eproto = {
  false, InitDefaults_planning_5fconf_2eproto, 
  "\n\023planning_conf.proto\022\010planning\"\215\002\n\007RRTC"
  "onf\022\021\n\ttime_step\030\001 \001(\001\022\021\n\tk_voronoi\030\002 \001("
  "\001\022\016\n\006k_goal\030\003 \001(\001\022\022\n\nshow_image\030\004 \001(\010\022\022\n"
  "\nmax_attemp\030\005 \001(\005\022\021\n\tstep_size\030\006 \001(\005\022\025\n\r"
  "turn_on_prior\030\007 \001(\010\022\023\n\013k_repulsive\030\010 \001(\001"
  "\022\026\n\016post_iteration\030\t \001(\005\022\016\n\006record\030\n \001(\010"
  "\022\023\n\013record_path\030\013 \001(\t\022\026\n\016uniform_sample\030"
  "\014 \001(\010\022\020\n\010pivots_k\030\r \001(\005\"l\n\010VrepConf\022\023\n\013r"
  "esolutionX\030\001 \001(\005\022\023\n\013resolutionY\030\002 \001(\005\022\014\n"
  "\004minX\030\003 \001(\001\022\014\n\004maxX\030\004 \001(\001\022\014\n\004minY\030\005 \001(\001\022"
  "\014\n\004maxY\030\006 \001(\001\" \n\004Goal\022\013\n\003row\030\001 \001(\001\022\013\n\003co"
  "l\030\002 \001(\001\"0\n\tFakeState\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001"
  "(\001\022\r\n\005theta\030\003 \001(\001\"\340\001\n\014PlanningConf\022\024\n\014us"
  "e_sim_time\030\001 \001(\010\022#\n\010rrt_conf\030\002 \001(\0132\021.pla"
  "nning.RRTConf\022%\n\tvrep_conf\030\003 \001(\0132\022.plann"
  "ing.VrepConf\022\034\n\004goal\030\004 \001(\0132\016.planning.Go"
  "al\022\025\n\rmap_from_file\030\005 \001(\010\022\020\n\010map_path\030\006 "
  "\001(\t\022\'\n\nfake_state\030\007 \001(\0132\023.planning.FakeS"
  "tate"
,
  "planning_conf.proto", &assign_descriptors_table_planning_5fconf_2eproto, 724,
};

void AddDescriptors_planning_5fconf_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[1] =
  {
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_planning_5fconf_2eproto, deps, 0);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_planning_5fconf_2eproto = []() { AddDescriptors_planning_5fconf_2eproto(); return true; }();
namespace planning {

// ===================================================================

void RRTConf::InitAsDefaultInstance() {
}
class RRTConf::HasBitSetters {
 public:
  static void set_has_time_step(RRTConf* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_k_voronoi(RRTConf* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_k_goal(RRTConf* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_show_image(RRTConf* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_max_attemp(RRTConf* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_step_size(RRTConf* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_turn_on_prior(RRTConf* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_k_repulsive(RRTConf* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_post_iteration(RRTConf* msg) {
    msg->_has_bits_[0] |= 0x00000800u;
  }
  static void set_has_record(RRTConf* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
  static void set_has_record_path(RRTConf* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_uniform_sample(RRTConf* msg) {
    msg->_has_bits_[0] |= 0x00000400u;
  }
  static void set_has_pivots_k(RRTConf* msg) {
    msg->_has_bits_[0] |= 0x00001000u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RRTConf::kTimeStepFieldNumber;
const int RRTConf::kKVoronoiFieldNumber;
const int RRTConf::kKGoalFieldNumber;
const int RRTConf::kShowImageFieldNumber;
const int RRTConf::kMaxAttempFieldNumber;
const int RRTConf::kStepSizeFieldNumber;
const int RRTConf::kTurnOnPriorFieldNumber;
const int RRTConf::kKRepulsiveFieldNumber;
const int RRTConf::kPostIterationFieldNumber;
const int RRTConf::kRecordFieldNumber;
const int RRTConf::kRecordPathFieldNumber;
const int RRTConf::kUniformSampleFieldNumber;
const int RRTConf::kPivotsKFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RRTConf::RRTConf()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:planning.RRTConf)
}
RRTConf::RRTConf(const RRTConf& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  record_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_record_path()) {
    record_path_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.record_path_);
  }
  ::memcpy(&time_step_, &from.time_step_,
    static_cast<size_t>(reinterpret_cast<char*>(&pivots_k_) -
    reinterpret_cast<char*>(&time_step_)) + sizeof(pivots_k_));
  // @@protoc_insertion_point(copy_constructor:planning.RRTConf)
}

void RRTConf::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_RRTConf_planning_5fconf_2eproto.base);
  record_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&time_step_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pivots_k_) -
      reinterpret_cast<char*>(&time_step_)) + sizeof(pivots_k_));
}

RRTConf::~RRTConf() {
  // @@protoc_insertion_point(destructor:planning.RRTConf)
  SharedDtor();
}

void RRTConf::SharedDtor() {
  record_path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void RRTConf::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RRTConf& RRTConf::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_RRTConf_planning_5fconf_2eproto.base);
  return *internal_default_instance();
}


void RRTConf::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.RRTConf)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    record_path_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&time_step_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&show_image_) -
        reinterpret_cast<char*>(&time_step_)) + sizeof(show_image_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&turn_on_prior_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pivots_k_) -
        reinterpret_cast<char*>(&turn_on_prior_)) + sizeof(pivots_k_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RRTConf::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<RRTConf*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional double time_step = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_time_step(val);
        break;
      }
      // optional double k_voronoi = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_k_voronoi(val);
        break;
      }
      // optional double k_goal = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_k_goal(val);
        break;
      }
      // optional bool show_image = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        bool value = val;
        msg->set_show_image(value);
        break;
      }
      // optional int32 max_attemp = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_max_attemp(value);
        break;
      }
      // optional int32 step_size = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_step_size(value);
        break;
      }
      // optional bool turn_on_prior = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        bool value = val;
        msg->set_turn_on_prior(value);
        break;
      }
      // optional double k_repulsive = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 65) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_k_repulsive(val);
        break;
      }
      // optional int32 post_iteration = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 72) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_post_iteration(value);
        break;
      }
      // optional bool record = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 80) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        bool value = val;
        msg->set_record(value);
        break;
      }
      // optional string record_path = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 90) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("planning.RRTConf.record_path");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8Verify;
        ::std::string* str = msg->mutable_record_path();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // optional bool uniform_sample = 12;
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 96) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        bool value = val;
        msg->set_uniform_sample(value);
        break;
      }
      // optional int32 pivots_k = 13;
      case 13: {
        if (static_cast<::google::protobuf::uint8>(tag) != 104) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_pivots_k(value);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RRTConf::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:planning.RRTConf)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double time_step = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_time_step(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &time_step_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double k_voronoi = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_k_voronoi(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &k_voronoi_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double k_goal = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_k_goal(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &k_goal_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool show_image = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_show_image(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_image_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 max_attemp = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_max_attemp(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_attemp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 step_size = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_step_size(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &step_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool turn_on_prior = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_turn_on_prior(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &turn_on_prior_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double k_repulsive = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (65 & 0xFF)) {
          HasBitSetters::set_has_k_repulsive(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &k_repulsive_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 post_iteration = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_post_iteration(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &post_iteration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool record = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (80 & 0xFF)) {
          HasBitSetters::set_has_record(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &record_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string record_path = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (90 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_record_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->record_path().data(), static_cast<int>(this->record_path().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "planning.RRTConf.record_path");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool uniform_sample = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_uniform_sample(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &uniform_sample_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 pivots_k = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (104 & 0xFF)) {
          HasBitSetters::set_has_pivots_k(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pivots_k_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:planning.RRTConf)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:planning.RRTConf)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RRTConf::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:planning.RRTConf)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double time_step = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->time_step(), output);
  }

  // optional double k_voronoi = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->k_voronoi(), output);
  }

  // optional double k_goal = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->k_goal(), output);
  }

  // optional bool show_image = 4;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->show_image(), output);
  }

  // optional int32 max_attemp = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->max_attemp(), output);
  }

  // optional int32 step_size = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->step_size(), output);
  }

  // optional bool turn_on_prior = 7;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->turn_on_prior(), output);
  }

  // optional double k_repulsive = 8;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->k_repulsive(), output);
  }

  // optional int32 post_iteration = 9;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->post_iteration(), output);
  }

  // optional bool record = 10;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->record(), output);
  }

  // optional string record_path = 11;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->record_path().data(), static_cast<int>(this->record_path().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "planning.RRTConf.record_path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      11, this->record_path(), output);
  }

  // optional bool uniform_sample = 12;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->uniform_sample(), output);
  }

  // optional int32 pivots_k = 13;
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(13, this->pivots_k(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:planning.RRTConf)
}

::google::protobuf::uint8* RRTConf::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:planning.RRTConf)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double time_step = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->time_step(), target);
  }

  // optional double k_voronoi = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->k_voronoi(), target);
  }

  // optional double k_goal = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->k_goal(), target);
  }

  // optional bool show_image = 4;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->show_image(), target);
  }

  // optional int32 max_attemp = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->max_attemp(), target);
  }

  // optional int32 step_size = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->step_size(), target);
  }

  // optional bool turn_on_prior = 7;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->turn_on_prior(), target);
  }

  // optional double k_repulsive = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->k_repulsive(), target);
  }

  // optional int32 post_iteration = 9;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->post_iteration(), target);
  }

  // optional bool record = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(10, this->record(), target);
  }

  // optional string record_path = 11;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->record_path().data(), static_cast<int>(this->record_path().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "planning.RRTConf.record_path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->record_path(), target);
  }

  // optional bool uniform_sample = 12;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->uniform_sample(), target);
  }

  // optional int32 pivots_k = 13;
  if (cached_has_bits & 0x00001000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(13, this->pivots_k(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.RRTConf)
  return target;
}

size_t RRTConf::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.RRTConf)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string record_path = 11;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->record_path());
    }

    // optional double time_step = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double k_voronoi = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double k_goal = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional int32 max_attemp = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_attemp());
    }

    // optional int32 step_size = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->step_size());
    }

    // optional double k_repulsive = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional bool show_image = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional bool turn_on_prior = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool record = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool uniform_sample = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional int32 post_iteration = 9;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->post_iteration());
    }

    // optional int32 pivots_k = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pivots_k());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RRTConf::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.RRTConf)
  GOOGLE_DCHECK_NE(&from, this);
  const RRTConf* source =
      ::google::protobuf::DynamicCastToGenerated<RRTConf>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.RRTConf)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.RRTConf)
    MergeFrom(*source);
  }
}

void RRTConf::MergeFrom(const RRTConf& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.RRTConf)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      record_path_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.record_path_);
    }
    if (cached_has_bits & 0x00000002u) {
      time_step_ = from.time_step_;
    }
    if (cached_has_bits & 0x00000004u) {
      k_voronoi_ = from.k_voronoi_;
    }
    if (cached_has_bits & 0x00000008u) {
      k_goal_ = from.k_goal_;
    }
    if (cached_has_bits & 0x00000010u) {
      max_attemp_ = from.max_attemp_;
    }
    if (cached_has_bits & 0x00000020u) {
      step_size_ = from.step_size_;
    }
    if (cached_has_bits & 0x00000040u) {
      k_repulsive_ = from.k_repulsive_;
    }
    if (cached_has_bits & 0x00000080u) {
      show_image_ = from.show_image_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      turn_on_prior_ = from.turn_on_prior_;
    }
    if (cached_has_bits & 0x00000200u) {
      record_ = from.record_;
    }
    if (cached_has_bits & 0x00000400u) {
      uniform_sample_ = from.uniform_sample_;
    }
    if (cached_has_bits & 0x00000800u) {
      post_iteration_ = from.post_iteration_;
    }
    if (cached_has_bits & 0x00001000u) {
      pivots_k_ = from.pivots_k_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RRTConf::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.RRTConf)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RRTConf::CopyFrom(const RRTConf& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.RRTConf)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RRTConf::IsInitialized() const {
  return true;
}

void RRTConf::Swap(RRTConf* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RRTConf::InternalSwap(RRTConf* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  record_path_.Swap(&other->record_path_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(time_step_, other->time_step_);
  swap(k_voronoi_, other->k_voronoi_);
  swap(k_goal_, other->k_goal_);
  swap(max_attemp_, other->max_attemp_);
  swap(step_size_, other->step_size_);
  swap(k_repulsive_, other->k_repulsive_);
  swap(show_image_, other->show_image_);
  swap(turn_on_prior_, other->turn_on_prior_);
  swap(record_, other->record_);
  swap(uniform_sample_, other->uniform_sample_);
  swap(post_iteration_, other->post_iteration_);
  swap(pivots_k_, other->pivots_k_);
}

::google::protobuf::Metadata RRTConf::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_planning_5fconf_2eproto);
  return ::file_level_metadata_planning_5fconf_2eproto[kIndexInFileMessages];
}


// ===================================================================

void VrepConf::InitAsDefaultInstance() {
}
class VrepConf::HasBitSetters {
 public:
  static void set_has_resolutionx(VrepConf* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_resolutiony(VrepConf* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_minx(VrepConf* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_maxx(VrepConf* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_miny(VrepConf* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_maxy(VrepConf* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VrepConf::kResolutionXFieldNumber;
const int VrepConf::kResolutionYFieldNumber;
const int VrepConf::kMinXFieldNumber;
const int VrepConf::kMaxXFieldNumber;
const int VrepConf::kMinYFieldNumber;
const int VrepConf::kMaxYFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VrepConf::VrepConf()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:planning.VrepConf)
}
VrepConf::VrepConf(const VrepConf& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&resolutionx_, &from.resolutionx_,
    static_cast<size_t>(reinterpret_cast<char*>(&maxy_) -
    reinterpret_cast<char*>(&resolutionx_)) + sizeof(maxy_));
  // @@protoc_insertion_point(copy_constructor:planning.VrepConf)
}

void VrepConf::SharedCtor() {
  ::memset(&resolutionx_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&maxy_) -
      reinterpret_cast<char*>(&resolutionx_)) + sizeof(maxy_));
}

VrepConf::~VrepConf() {
  // @@protoc_insertion_point(destructor:planning.VrepConf)
  SharedDtor();
}

void VrepConf::SharedDtor() {
}

void VrepConf::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const VrepConf& VrepConf::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_VrepConf_planning_5fconf_2eproto.base);
  return *internal_default_instance();
}


void VrepConf::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.VrepConf)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&resolutionx_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&maxy_) -
        reinterpret_cast<char*>(&resolutionx_)) + sizeof(maxy_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* VrepConf::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<VrepConf*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional int32 resolutionX = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_resolutionx(value);
        break;
      }
      // optional int32 resolutionY = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_resolutiony(value);
        break;
      }
      // optional double minX = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_minx(val);
        break;
      }
      // optional double maxX = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 33) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_maxx(val);
        break;
      }
      // optional double minY = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 41) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_miny(val);
        break;
      }
      // optional double maxY = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 49) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_maxy(val);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool VrepConf::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:planning.VrepConf)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 resolutionX = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_resolutionx(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &resolutionx_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 resolutionY = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_resolutiony(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &resolutiony_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double minX = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_minx(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &minx_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double maxX = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (33 & 0xFF)) {
          HasBitSetters::set_has_maxx(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &maxx_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double minY = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (41 & 0xFF)) {
          HasBitSetters::set_has_miny(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &miny_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double maxY = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (49 & 0xFF)) {
          HasBitSetters::set_has_maxy(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &maxy_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:planning.VrepConf)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:planning.VrepConf)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void VrepConf::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:planning.VrepConf)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 resolutionX = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->resolutionx(), output);
  }

  // optional int32 resolutionY = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->resolutiony(), output);
  }

  // optional double minX = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->minx(), output);
  }

  // optional double maxX = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->maxx(), output);
  }

  // optional double minY = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->miny(), output);
  }

  // optional double maxY = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->maxy(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:planning.VrepConf)
}

::google::protobuf::uint8* VrepConf::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:planning.VrepConf)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 resolutionX = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->resolutionx(), target);
  }

  // optional int32 resolutionY = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->resolutiony(), target);
  }

  // optional double minX = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->minx(), target);
  }

  // optional double maxX = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->maxx(), target);
  }

  // optional double minY = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->miny(), target);
  }

  // optional double maxY = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->maxy(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.VrepConf)
  return target;
}

size_t VrepConf::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.VrepConf)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional int32 resolutionX = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resolutionx());
    }

    // optional int32 resolutionY = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resolutiony());
    }

    // optional double minX = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double maxX = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double minY = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double maxY = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VrepConf::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.VrepConf)
  GOOGLE_DCHECK_NE(&from, this);
  const VrepConf* source =
      ::google::protobuf::DynamicCastToGenerated<VrepConf>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.VrepConf)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.VrepConf)
    MergeFrom(*source);
  }
}

void VrepConf::MergeFrom(const VrepConf& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.VrepConf)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      resolutionx_ = from.resolutionx_;
    }
    if (cached_has_bits & 0x00000002u) {
      resolutiony_ = from.resolutiony_;
    }
    if (cached_has_bits & 0x00000004u) {
      minx_ = from.minx_;
    }
    if (cached_has_bits & 0x00000008u) {
      maxx_ = from.maxx_;
    }
    if (cached_has_bits & 0x00000010u) {
      miny_ = from.miny_;
    }
    if (cached_has_bits & 0x00000020u) {
      maxy_ = from.maxy_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void VrepConf::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.VrepConf)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VrepConf::CopyFrom(const VrepConf& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.VrepConf)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VrepConf::IsInitialized() const {
  return true;
}

void VrepConf::Swap(VrepConf* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VrepConf::InternalSwap(VrepConf* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(resolutionx_, other->resolutionx_);
  swap(resolutiony_, other->resolutiony_);
  swap(minx_, other->minx_);
  swap(maxx_, other->maxx_);
  swap(miny_, other->miny_);
  swap(maxy_, other->maxy_);
}

::google::protobuf::Metadata VrepConf::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_planning_5fconf_2eproto);
  return ::file_level_metadata_planning_5fconf_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Goal::InitAsDefaultInstance() {
}
class Goal::HasBitSetters {
 public:
  static void set_has_row(Goal* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_col(Goal* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Goal::kRowFieldNumber;
const int Goal::kColFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Goal::Goal()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:planning.Goal)
}
Goal::Goal(const Goal& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&row_, &from.row_,
    static_cast<size_t>(reinterpret_cast<char*>(&col_) -
    reinterpret_cast<char*>(&row_)) + sizeof(col_));
  // @@protoc_insertion_point(copy_constructor:planning.Goal)
}

void Goal::SharedCtor() {
  ::memset(&row_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&col_) -
      reinterpret_cast<char*>(&row_)) + sizeof(col_));
}

Goal::~Goal() {
  // @@protoc_insertion_point(destructor:planning.Goal)
  SharedDtor();
}

void Goal::SharedDtor() {
}

void Goal::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Goal& Goal::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Goal_planning_5fconf_2eproto.base);
  return *internal_default_instance();
}


void Goal::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.Goal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&row_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&col_) -
        reinterpret_cast<char*>(&row_)) + sizeof(col_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Goal::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Goal*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional double row = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_row(val);
        break;
      }
      // optional double col = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_col(val);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Goal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:planning.Goal)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double row = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_row(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &row_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double col = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_col(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &col_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:planning.Goal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:planning.Goal)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Goal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:planning.Goal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double row = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->row(), output);
  }

  // optional double col = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->col(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:planning.Goal)
}

::google::protobuf::uint8* Goal::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:planning.Goal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double row = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->row(), target);
  }

  // optional double col = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->col(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.Goal)
  return target;
}

size_t Goal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.Goal)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double row = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double col = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Goal::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.Goal)
  GOOGLE_DCHECK_NE(&from, this);
  const Goal* source =
      ::google::protobuf::DynamicCastToGenerated<Goal>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.Goal)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.Goal)
    MergeFrom(*source);
  }
}

void Goal::MergeFrom(const Goal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.Goal)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      row_ = from.row_;
    }
    if (cached_has_bits & 0x00000002u) {
      col_ = from.col_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Goal::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.Goal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Goal::CopyFrom(const Goal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.Goal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Goal::IsInitialized() const {
  return true;
}

void Goal::Swap(Goal* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Goal::InternalSwap(Goal* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(row_, other->row_);
  swap(col_, other->col_);
}

::google::protobuf::Metadata Goal::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_planning_5fconf_2eproto);
  return ::file_level_metadata_planning_5fconf_2eproto[kIndexInFileMessages];
}


// ===================================================================

void FakeState::InitAsDefaultInstance() {
}
class FakeState::HasBitSetters {
 public:
  static void set_has_x(FakeState* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_y(FakeState* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_theta(FakeState* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FakeState::kXFieldNumber;
const int FakeState::kYFieldNumber;
const int FakeState::kThetaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FakeState::FakeState()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:planning.FakeState)
}
FakeState::FakeState(const FakeState& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&theta_) -
    reinterpret_cast<char*>(&x_)) + sizeof(theta_));
  // @@protoc_insertion_point(copy_constructor:planning.FakeState)
}

void FakeState::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&theta_) -
      reinterpret_cast<char*>(&x_)) + sizeof(theta_));
}

FakeState::~FakeState() {
  // @@protoc_insertion_point(destructor:planning.FakeState)
  SharedDtor();
}

void FakeState::SharedDtor() {
}

void FakeState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FakeState& FakeState::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_FakeState_planning_5fconf_2eproto.base);
  return *internal_default_instance();
}


void FakeState::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.FakeState)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&theta_) -
        reinterpret_cast<char*>(&x_)) + sizeof(theta_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* FakeState::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<FakeState*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional double x = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_x(val);
        break;
      }
      // optional double y = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_y(val);
        break;
      }
      // optional double theta = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_theta(val);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool FakeState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:planning.FakeState)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_x(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_y(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double theta = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_theta(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &theta_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:planning.FakeState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:planning.FakeState)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void FakeState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:planning.FakeState)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // optional double theta = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->theta(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:planning.FakeState)
}

::google::protobuf::uint8* FakeState::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:planning.FakeState)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // optional double theta = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->theta(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.FakeState)
  return target;
}

size_t FakeState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.FakeState)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double theta = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FakeState::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.FakeState)
  GOOGLE_DCHECK_NE(&from, this);
  const FakeState* source =
      ::google::protobuf::DynamicCastToGenerated<FakeState>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.FakeState)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.FakeState)
    MergeFrom(*source);
  }
}

void FakeState::MergeFrom(const FakeState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.FakeState)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      theta_ = from.theta_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FakeState::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.FakeState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FakeState::CopyFrom(const FakeState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.FakeState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FakeState::IsInitialized() const {
  return true;
}

void FakeState::Swap(FakeState* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FakeState::InternalSwap(FakeState* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(theta_, other->theta_);
}

::google::protobuf::Metadata FakeState::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_planning_5fconf_2eproto);
  return ::file_level_metadata_planning_5fconf_2eproto[kIndexInFileMessages];
}


// ===================================================================

void PlanningConf::InitAsDefaultInstance() {
  ::planning::_PlanningConf_default_instance_._instance.get_mutable()->rrt_conf_ = const_cast< ::planning::RRTConf*>(
      ::planning::RRTConf::internal_default_instance());
  ::planning::_PlanningConf_default_instance_._instance.get_mutable()->vrep_conf_ = const_cast< ::planning::VrepConf*>(
      ::planning::VrepConf::internal_default_instance());
  ::planning::_PlanningConf_default_instance_._instance.get_mutable()->goal_ = const_cast< ::planning::Goal*>(
      ::planning::Goal::internal_default_instance());
  ::planning::_PlanningConf_default_instance_._instance.get_mutable()->fake_state_ = const_cast< ::planning::FakeState*>(
      ::planning::FakeState::internal_default_instance());
}
class PlanningConf::HasBitSetters {
 public:
  static void set_has_use_sim_time(PlanningConf* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static const ::planning::RRTConf& rrt_conf(const PlanningConf* msg);
  static void set_has_rrt_conf(PlanningConf* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::planning::VrepConf& vrep_conf(const PlanningConf* msg);
  static void set_has_vrep_conf(PlanningConf* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static const ::planning::Goal& goal(const PlanningConf* msg);
  static void set_has_goal(PlanningConf* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_map_from_file(PlanningConf* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_map_path(PlanningConf* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::planning::FakeState& fake_state(const PlanningConf* msg);
  static void set_has_fake_state(PlanningConf* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

const ::planning::RRTConf&
PlanningConf::HasBitSetters::rrt_conf(const PlanningConf* msg) {
  return *msg->rrt_conf_;
}
const ::planning::VrepConf&
PlanningConf::HasBitSetters::vrep_conf(const PlanningConf* msg) {
  return *msg->vrep_conf_;
}
const ::planning::Goal&
PlanningConf::HasBitSetters::goal(const PlanningConf* msg) {
  return *msg->goal_;
}
const ::planning::FakeState&
PlanningConf::HasBitSetters::fake_state(const PlanningConf* msg) {
  return *msg->fake_state_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PlanningConf::kUseSimTimeFieldNumber;
const int PlanningConf::kRrtConfFieldNumber;
const int PlanningConf::kVrepConfFieldNumber;
const int PlanningConf::kGoalFieldNumber;
const int PlanningConf::kMapFromFileFieldNumber;
const int PlanningConf::kMapPathFieldNumber;
const int PlanningConf::kFakeStateFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PlanningConf::PlanningConf()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:planning.PlanningConf)
}
PlanningConf::PlanningConf(const PlanningConf& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  map_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_map_path()) {
    map_path_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.map_path_);
  }
  if (from.has_rrt_conf()) {
    rrt_conf_ = new ::planning::RRTConf(*from.rrt_conf_);
  } else {
    rrt_conf_ = NULL;
  }
  if (from.has_vrep_conf()) {
    vrep_conf_ = new ::planning::VrepConf(*from.vrep_conf_);
  } else {
    vrep_conf_ = NULL;
  }
  if (from.has_goal()) {
    goal_ = new ::planning::Goal(*from.goal_);
  } else {
    goal_ = NULL;
  }
  if (from.has_fake_state()) {
    fake_state_ = new ::planning::FakeState(*from.fake_state_);
  } else {
    fake_state_ = NULL;
  }
  ::memcpy(&use_sim_time_, &from.use_sim_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&map_from_file_) -
    reinterpret_cast<char*>(&use_sim_time_)) + sizeof(map_from_file_));
  // @@protoc_insertion_point(copy_constructor:planning.PlanningConf)
}

void PlanningConf::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_PlanningConf_planning_5fconf_2eproto.base);
  map_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&rrt_conf_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&map_from_file_) -
      reinterpret_cast<char*>(&rrt_conf_)) + sizeof(map_from_file_));
}

PlanningConf::~PlanningConf() {
  // @@protoc_insertion_point(destructor:planning.PlanningConf)
  SharedDtor();
}

void PlanningConf::SharedDtor() {
  map_path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete rrt_conf_;
  if (this != internal_default_instance()) delete vrep_conf_;
  if (this != internal_default_instance()) delete goal_;
  if (this != internal_default_instance()) delete fake_state_;
}

void PlanningConf::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PlanningConf& PlanningConf::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_PlanningConf_planning_5fconf_2eproto.base);
  return *internal_default_instance();
}


void PlanningConf::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.PlanningConf)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      map_path_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(rrt_conf_ != NULL);
      rrt_conf_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(vrep_conf_ != NULL);
      vrep_conf_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(goal_ != NULL);
      goal_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(fake_state_ != NULL);
      fake_state_->Clear();
    }
  }
  ::memset(&use_sim_time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&map_from_file_) -
      reinterpret_cast<char*>(&use_sim_time_)) + sizeof(map_from_file_));
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PlanningConf::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<PlanningConf*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional bool use_sim_time = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        bool value = val;
        msg->set_use_sim_time(value);
        break;
      }
      // optional .planning.RRTConf rrt_conf = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::planning::RRTConf::_InternalParse;
        object = msg->mutable_rrt_conf();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // optional .planning.VrepConf vrep_conf = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::planning::VrepConf::_InternalParse;
        object = msg->mutable_vrep_conf();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // optional .planning.Goal goal = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::planning::Goal::_InternalParse;
        object = msg->mutable_goal();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // optional bool map_from_file = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        bool value = val;
        msg->set_map_from_file(value);
        break;
      }
      // optional string map_path = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("planning.PlanningConf.map_path");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8Verify;
        ::std::string* str = msg->mutable_map_path();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // optional .planning.FakeState fake_state = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::planning::FakeState::_InternalParse;
        object = msg->mutable_fake_state();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PlanningConf::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:planning.PlanningConf)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool use_sim_time = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_use_sim_time(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_sim_time_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .planning.RRTConf rrt_conf = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_rrt_conf()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .planning.VrepConf vrep_conf = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_vrep_conf()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .planning.Goal goal = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_goal()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool map_from_file = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_map_from_file(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &map_from_file_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string map_path = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_map_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->map_path().data(), static_cast<int>(this->map_path().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "planning.PlanningConf.map_path");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .planning.FakeState fake_state = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_fake_state()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:planning.PlanningConf)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:planning.PlanningConf)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PlanningConf::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:planning.PlanningConf)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool use_sim_time = 1;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->use_sim_time(), output);
  }

  // optional .planning.RRTConf rrt_conf = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::rrt_conf(this), output);
  }

  // optional .planning.VrepConf vrep_conf = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::vrep_conf(this), output);
  }

  // optional .planning.Goal goal = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::goal(this), output);
  }

  // optional bool map_from_file = 5;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->map_from_file(), output);
  }

  // optional string map_path = 6;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->map_path().data(), static_cast<int>(this->map_path().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "planning.PlanningConf.map_path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->map_path(), output);
  }

  // optional .planning.FakeState fake_state = 7;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, HasBitSetters::fake_state(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:planning.PlanningConf)
}

::google::protobuf::uint8* PlanningConf::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:planning.PlanningConf)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool use_sim_time = 1;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->use_sim_time(), target);
  }

  // optional .planning.RRTConf rrt_conf = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::rrt_conf(this), deterministic, target);
  }

  // optional .planning.VrepConf vrep_conf = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::vrep_conf(this), deterministic, target);
  }

  // optional .planning.Goal goal = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::goal(this), deterministic, target);
  }

  // optional bool map_from_file = 5;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->map_from_file(), target);
  }

  // optional string map_path = 6;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->map_path().data(), static_cast<int>(this->map_path().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "planning.PlanningConf.map_path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->map_path(), target);
  }

  // optional .planning.FakeState fake_state = 7;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, HasBitSetters::fake_state(this), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.PlanningConf)
  return target;
}

size_t PlanningConf::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.PlanningConf)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string map_path = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->map_path());
    }

    // optional .planning.RRTConf rrt_conf = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *rrt_conf_);
    }

    // optional .planning.VrepConf vrep_conf = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *vrep_conf_);
    }

    // optional .planning.Goal goal = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *goal_);
    }

    // optional .planning.FakeState fake_state = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *fake_state_);
    }

    // optional bool use_sim_time = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool map_from_file = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PlanningConf::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.PlanningConf)
  GOOGLE_DCHECK_NE(&from, this);
  const PlanningConf* source =
      ::google::protobuf::DynamicCastToGenerated<PlanningConf>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.PlanningConf)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.PlanningConf)
    MergeFrom(*source);
  }
}

void PlanningConf::MergeFrom(const PlanningConf& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.PlanningConf)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      map_path_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.map_path_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_rrt_conf()->::planning::RRTConf::MergeFrom(from.rrt_conf());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_vrep_conf()->::planning::VrepConf::MergeFrom(from.vrep_conf());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_goal()->::planning::Goal::MergeFrom(from.goal());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_fake_state()->::planning::FakeState::MergeFrom(from.fake_state());
    }
    if (cached_has_bits & 0x00000020u) {
      use_sim_time_ = from.use_sim_time_;
    }
    if (cached_has_bits & 0x00000040u) {
      map_from_file_ = from.map_from_file_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PlanningConf::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.PlanningConf)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlanningConf::CopyFrom(const PlanningConf& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.PlanningConf)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlanningConf::IsInitialized() const {
  return true;
}

void PlanningConf::Swap(PlanningConf* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PlanningConf::InternalSwap(PlanningConf* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  map_path_.Swap(&other->map_path_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(rrt_conf_, other->rrt_conf_);
  swap(vrep_conf_, other->vrep_conf_);
  swap(goal_, other->goal_);
  swap(fake_state_, other->fake_state_);
  swap(use_sim_time_, other->use_sim_time_);
  swap(map_from_file_, other->map_from_file_);
}

::google::protobuf::Metadata PlanningConf::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_planning_5fconf_2eproto);
  return ::file_level_metadata_planning_5fconf_2eproto[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace planning
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::planning::RRTConf* Arena::CreateMaybeMessage< ::planning::RRTConf >(Arena* arena) {
  return Arena::CreateInternal< ::planning::RRTConf >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::VrepConf* Arena::CreateMaybeMessage< ::planning::VrepConf >(Arena* arena) {
  return Arena::CreateInternal< ::planning::VrepConf >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::Goal* Arena::CreateMaybeMessage< ::planning::Goal >(Arena* arena) {
  return Arena::CreateInternal< ::planning::Goal >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::FakeState* Arena::CreateMaybeMessage< ::planning::FakeState >(Arena* arena) {
  return Arena::CreateInternal< ::planning::FakeState >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::PlanningConf* Arena::CreateMaybeMessage< ::planning::PlanningConf >(Arena* arena) {
  return Arena::CreateInternal< ::planning::PlanningConf >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
